---
aip:
  id: 5000
  state: draft
  created: 2020-01-15
js:
  - /assets/js/graphviz/viz.js
  - /assets/js/graphviz/lite.render.js
  - /assets/js/aip/aip-graphviz.js
permalink: /5000
---

# Messaging

[**JSON**](https://www.json.org/)** SHOULD be used as the representation type** unless there is a **pressing reason** not to in which case have a conversation with a TRB or VAT member and define clearly the reason for the exception. For example, performance optimization, support of alternate types because of merchant integration, etc. ReST allows for multiple representation types that can be resolved by content negotiation.

This document was designed for HTTP 1.1 and MAY be applicable to later versions of the same transport protocol.

# HTTP Headers
Namespace Salesforce headers used by the application with** **`sfdc-{HeaderName}`.** **Do not use `X`** **to prefix your header. The practice of adding such prefix dates back to August 13, 1982 with the precursor of email: [RFC822](https://tools.ietf.org/html/rfc822). The practice was, however, removed in the latter document [RFC2822](https://tools.ietf.org/html/rfc2822).  Likewise, although it was originally considered a common good practice in HTTP by heritage of email, it was eventually removed by June 2012 in [RFC6648](http://tools.ietf.org/html/rfc6648). This document takes the same stance than [RFC6648](http://tools.ietf.org/html/rfc6648) and understands the `X-` as an undesirable prefix which negative effects overshadow its benefits.

Parameters that affect the *behavior* of an API MUST NOT be passed via an HTTP Header. Exceptions are granted for headers that are already part of the [W3C standard](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html).

# TLS Everywhere
TLS MUST be used everywhere. Encrypted communication is preferred over non-encrypted for obvious security reasons and its not worth the effort of sweating its cons. TLS adds additional cost to the transport but the cost is not significant compared to the benefits. MaxCDN found a 5ms latency when testing encrypted vs un-encrypted connections with an increase of 2% of CPU.  With *HTTP/2 *one can expect this to only be faster due fewer network trips for data exchange. One should also note that while it might not be beneficial for API's, the use of TLS has [SEO benefits](https://searchengineland.com/google-starts-giving-ranking-boost-secure-httpsssl-sites-199446) over non SEO resources.


> Certificate Management solutions will need to be provided on GCP and AWS for E-W traffic.


References

*  http://www.hostingadvice.com/how-to/tls-vs-ssl/
* https://geemus.gitbooks.io/http-api-design/content/en/foundations/require-secure-connections.html

# Asynchronous Operations

HTTP has a synchronous request-response model where HTTP requests timeout if there is a period of inactivity. There are operations that could take hours or days and keeping a HTTP request alive without timing out after such period of inactivity might not work. 

The *Async pattern *is used to handle such scenarios for handling long running tasks.

Lets say we have service that does job processing from RESTful Web Services example: 

```
POST /jobs HTTP/1.1
Host: [jobs.cc.salesforce.com](http://jobs.cc.salesforce.com/) 

Give me the prime factorization of this 10,00000 digit number
....
```

The server would accept this POST request, create a new Job and schedule it to run. This job could take a long time, so the server responds back to the client with a response stating that the job has been created and that the client can check it periodically for completion. **Asynchronous responses SHOULD use the `202` (Accepted) HTTP response status**.

```
202 Accepted
Location: https://jobs.cc.salesforce.com/jobs/job-1234
```

Once the job has been completed, the client can fetch the data from the resource. If the client makes a request while the job is still processing, then it will respond with a HTTP status of `202`. The Client can choose to `DELETE` the job during or after completion by deleting the job resource.
