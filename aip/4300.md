---
aip:
  id: 4300
  state: draft
  created: 2020-01-15
js:
  - /assets/js/graphviz/viz.js
  - /assets/js/graphviz/lite.render.js
  - /assets/js/aip/aip-graphviz.js
permalink: /4300
---

# Creation

To create single resources one of the following two possible approaches MUST be taken:

* `POST` to a collection, e.g: `POST /orders`.
* `PUT` to an id, e.g: PUT `/orders/my-client-side-generated-id`.

A resource action ([Resource Actions](https://salesforce.quip.com/Ft7PApbFhE3g#ZWGACAEczSy)) `create` MUST NOT be used under any circumstance.

**When the ID of the resource have to necessarily be created by the service the POST approach is RECOMMENDED**. POST on a collection resource like `/orders` with an entity subordinate to that resource can be compared to a file being subordinate to the directory containing it. I**f a resource is created as a result of the invocation, a HTTP response of 201 (Created) or 204 (No content) SHOULD be returned** which contains the status of the request and uses the HTTP [Location Header](https://en.wikipedia.org/wiki/HTTP_location) to refer to the created resource. An example is shown below where an order is created and the resource is returned:

```
HTTP/1.1 201 Created
Location: https://api.cc.salesforce.com/orders/202112

{"firstNumber": 10, "secondNumber": 20}
```

Or **in the case of deferring the return of the created resource, a 202 SHOULD be used.**

In the case of creations using `POST` the usage of the `Location` Header pointing to the resource SHOULD be used. In `PUT` it is RECOMMENDED.

**When the client side can safely generate an ID of the resource the `PUT` approach SHALL be preferred**. The main different is that PUT is idempotent and therefore between others the result can be cached, and the request can be safely retried in case of an error and therefore saving a sensible amount of lines of code to control side-cases when errors happen with an in-flight request. Response wise, but approaches behave similarly.

# Resource Creation with concurrency
It is possible that during the first creation of a resource there might exist an edge case where two separate clients attempt to create the same resource. To handle this, using the **If-None-Match** header with a value of *****, MAY be used to signify that the resource will only be created if it does not exist before.

```
Headers:
 If-None-Match:*
PUT /inventory-reservations/123
```

If a resource existed and the header was passed in for `If-None-Match`, the server should fail the request with a status code of `412 Precondition Failed`.

It is also possible that two clients can end up updating the same resource with one client sneaking in a change that goes un-detected by the other client. Consider an example of a record being updated in a UI and we have two users working on the same changes and submit their changes assuming their value were affecting a particular state, one users record could override the changes of the other user leading to non-deterministic behavior. 

To avoid this is optimistic concurrency control the use if the headers `If-Match` and `If-Unmodified-Since` to ensure optimistic locking is RECOMMENDED. In the event of concurrency, one client will receive a failure with a status code of `412` indicating  a Pre-Condition failed.

In the above example that uses GET/PUT (could use POST as well), consider Bob and Alice, both using Business Manager UI to modify the same Location Group, i.e., Location Group** 1**. When they requested the Group, they both received version “*abc*” which was last modified at date *Date-1*. Bob is able to make changes and submit first, so his request goes through as the Etag and `If-UnModified-Since` match up. When Alice on the other hand makes her changes and submits, the request will fail as the Etag and modified date do not match any longer and she would receive a `412 Pre Condition failed`.

Reference:

* https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests
